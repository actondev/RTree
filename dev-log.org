#+PROPERTY: header-args:sh :session *rtree*

* <2022-03-10 Thu> adding tests & refactoring
  #+begin_src sh
meson wrap search catch
meson wrap info catch2

meson wrap install catch2

meson configure build -Dtest=true
  #+end_src

  vector of vectors & reserve: https://stackoverflow.com/questions/16220915/how-to-reserve-memory-for-vector-of-vector

  used https://github.com/hebaishi/easy-cpp-print for printing out std::vector, std::vector<std::vector<t>> etc!
  no licence, oh well


** printing out vectors etc
   or just https://github.com/hebaishi/easy-cpp-print 
   #+begin_src cpp
template<typename T>
void print_vec(std::ostream &os, const std::vector<T> &vec) {
  auto size = vec.size();
  os << "{";
  for(auto i=0; i < size - 1; i++) {
    os << vec[i] << ",";
  }
  if(size > 0) {
    os << vec[size-1];
  }
  os << "}";
}

std::ostream &operator<<(std::ostream &os, const std::vector<int> &vec) {
  print_vec<int>(os, vec);
  return os;
}

std::ostream &operator<<(std::ostream &os, const std::vector<double> &vec) {
  print_vec<double>(os, vec);
  return os;
}

std::ostream &operator<<(std::ostream &os, const std::vector<std::vector<double>> &vec) {
  cerr << "{";
  for(const auto& x : vec) print_vec<double>(os, x);
  cerr << "}" << endl;
  return os;
}
   #+end_src

** test: sorting vector and equality
   #+begin_src cpp
std::sort(found.begin(), found.end(),
          [](const Type &a, const Type &b) {
            const auto size = std::min(a.size(), b.size());
            for(auto i=0; i < size; i++) {
              if ( a[i] < b[i]) {
                return true;
              }
            }
            return false;
          });
   #+end_src

   
** making grid
   #+begin_src cpp
std::vector<std::array<double, DIMS>> make_grid_template(int length)
{
  std::vector<std::array<double, DIMS>> res;
  int size = pow(length, DIMS);
  res.reserve(size);
  for (int i = 0; i < size; i++)
  {
    auto &el = res[i];
    for (int dim = 0; dim < DIMS; dim++)
    {
      int denum = pow(length, dim);
      int x = (int)(i / denum) % length;
      int mod = x % length;
      el[DIMS - dim - 1] = mod;
    }
    cerr << "  ";
    for(int i=0; i< DIMS; i++) {
      cerr << el[i] << ",";
    }
    cerr << endl;
  }

  return res;
}

std::vector<std::vector<double>> make_grid(int length, int dims = 2)
{
  std::vector<std::vector<double>> res;
  int size = pow(length, dims);
  res.resize(size);
  for (int i = 0; i < size; i++)
  {
    auto &el = res[i];
    el.resize(dims); // resize or reserve? kind of same?
    for (int dim = 0; dim < dims; dim++)
    {
      int denum = pow(length, dim);
      int x = (int)(i / denum) % length;
      int mod = x % length;
      el[dims - dim - 1] = mod;
    }
    cerr << "  ";
    for(int i=0; i< dims; i++) {
      cerr << el[i] << ",";
    }
    cerr << endl;
  }

  return res;
}
   #+end_src

* <2022-03-13 Sun> runtime only size
  started with using std::vector (for some reason) to store the Rects.. the result was timing ~ *10.
  Ofourse that was the first iteration, and then wanted to use some allocator:
  - a node has MAXNODES (default 8) branches (TODO fix this naming)
  - each branch has a rect: a rect is a vector of DIMS elements

  thus, I could preallocate =MAXNODES*(sizeof(Branch) + DIMS*sizeof(double))= , and then it can be used by all the branches (placement new) & from their Rects (new double[DIMS])

  <2022-03-13 Sun> fixes some issues: still though completely oblivious wrt move semantics, copy assignment etc..

  also see https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/

  
* <2022-03-15 Tue> profiling
  https://profiler.firefox.com/
  callgrind (a heap profiler called massif)
  
  #+begin_src sh
# pprof -web ./build/
sudo sh -c 'echo 1 >/proc/sys/kernel/perf_event_paranoid'

perf record -F 99 -g ./build/test/run-tests [benchmark]

perf script -F +pid > perf_ff.perf

perf

sudo apt install linux-tools-5.13.0-30-generic

sudo apt install linux-cloud-tools-generic

  #+end_src

  #+begin_src sh
rm -rf callgrind.out.*
valgrind --tool=callgrind ./build/test/run-tests "benchmark template version"
valgrind --tool=callgrind ./build/test/run-tests "benchmark"

valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose  ./build/test/run-tests # "benchmark"
  #+end_src

* <2022-03-16 Wed> overloading new etc
  - https://stackoverflow.com/questions/4638429/c-placement-new-vs-overloading-new
  - https://stackoverflow.com/questions/58225405/c-14-overload-new-operator-to-allocate-more-continuous-space-than-objects-s
    static_cast??
    https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used

    https://stackoverflow.com/questions/12215029/c-placement-new-collides-with-own-new-overload?rq=1

    https://bytes.com/topic/c/answers/583571-overriding-placement-new-correctly
    nice answers (quoting some c++ books)

    https://www.amazon.de/Modern-Generic-Programming-Patterns-Applied/dp/0201704315
    has a chapter for allocations
    as seen https://eli.thegreenplace.net/2011/02/17/the-many-faces-of-operator-new-in-c

* <2022-03-17 Thu> dynamic rtree: drtree
  - attempt some optimizations also to the existing library
  - compare vs the dynamic one drtree
  - compare cost of using a high MAXDIMS even when using smaller ones (as I had it)
    - memory used?


  - for 200x200 in dynamic version:
    ==69281==   total heap usage: 119,454 allocs, 119,454 frees, 10,671,421 bytes allocated
  - rtree with dimesions of 4:
    ==69400==   total heap usage: 213,955 allocs, 213,955 frees, 11,674,285 bytes allocated
    also had errors?
    ==69400== Invalid read of size 8
  - rtree with dimensions of 2:
    ==69842==   total heap usage: 218,824 allocs, 218,824 frees, 9,626,709 bytes allocated
    

  
* <2022-03-20 Sun> renamed to drtree, some mods
  200x2d (init only)
  was:
  total heap usage: 144,515 allocs, 144,515 frees, 11,283,940 bytes allocated
  
  after removing bool needs_cleanup (now constructing rect only with allocator):
  total heap usage: 119,490 allocs, 119,490 frees, 10,676,298 bytes allocated

  
** trying out using one array for the rect, offsetting index for min(low) vs max(high)
   - RectSphericalVolume was 301,312,719
   - combine_rects: 265,608,658
     
   - oh.. with refactor it's worse! 335,506,434
   - two arrays, but =double* const m_min=: 

    RTree (template version) has
     - RectSphericalVolume 268,915,845
     - CombineRect 256,292,035

** godbolt
   #+begin_src c++
#include <iostream>

using std::cout;

struct Rect {
    const int dims = 2;
    double low[2];
    double high[2];
    double volume() {
        double res = 0;
        for(int i=0; i<dims; i++) {
            res *= high[i] - low[i];
        }
        return res;
    }
};

struct Rect2 {
    const int dims;
    double* low;
    double* high;
    Rect2(int dims) :dims{dims} {
        low = new double[dims];
        high = new double[dims];
    }
    double volume() {
        double res = 0;
        for(int i=0; i<dims; i++) {
            res *= high[i] - low[i];
        }
        return res;
    }
};

double calc_volume(Rect* rect) {
    double res = 0;
        for(int i=0; i<rect->dims; i++) {
            res *= rect->high[i] - rect->low[i];
        }
    return res;
}

double calc_volume2(Rect2* rect) {
    double res = 0;
        for(int i=0; i<rect->dims; i++) {
            res *= rect->high[i] - rect->low[i];
        }
    return res;
}

int main() {
    Rect r;
    Rect2 r2(2);
    // double vol = r.volume();
    // double vol = calc_volume(&r);
    double vol = r2.volume();
    cout << "volume " << vol;

}
   #+end_src

   
* <2022-03-23 Wed> drtree2: trying the idea of handles vs pointers
  - <2022-03-23 Wed> MVP of having Rect being a handle, storing ALL rects in one std::vector
    the idea is that copy ctor for the rtree will be much faster
* rtree resources
  - https://www.cse.cuhk.edu.hk/~taoyf/course/infs4205/lec/rtree.pdf
  - https://livebook.manning.com/concept/algorithms/r-tree
  - http://www.mathcs.emory.edu/~cheung/Courses/554/Syllabus/3-index/R-tree.html
* terminology
  - a node has N branches (N=MAXNODES)
    - storing m_count for how many branches it stores
  - a branch is:
    - rect
    - data
    - Node* child
  - level 0 is for leafs? root has level > 0
    hmm I think level should be called =height= in this library


** insertion
   Insert(const ELEMTYPE *a_min, const ELEMTYPE *a_max, const DATATYPE &a_dataId)
   - Initializes a branch
   - calls InsertRect

   InsertRect(const Branch &a_branch, Node **a_root, a_level): called with 0 level
   inserts a rectangle into the data structure
   - InsertRectRec(const Branch &a_branch, Node **a_root, a_level
     (recursive)
     #+begin_src cpp
  if (InsertRectRec(a_branch, *a_root, &newNode, a_level)) // Root split
  {
    // Grow tree taller and new root
    Node *newRoot = AllocNode();
    newRoot->m_level = (*a_root)->m_level + 1;

    Branch branch;
     #+end_src
     returns true ifnode was split. if not, fine!, nothing extra to do


   InsertRectRec
   #+begin_src cpp
  // recurse until we reach the correct level for the new record. data records
  // will always be called with a_level == 0 (leaf)
  if (a_node->m_level > a_level) {
    // Still above level for insertion, go down tree recursively
    Node *otherNode;

    // find the optimal branch for this record
    int index = PickBranch(&a_branch.m_rect, a_node);


   #+end_src

   
*** TODO InsertRect: do not get argument Node**
    - return =std::optional<nid>= 
** pick branch
   #+begin_src cpp
// Pick a branch.  Pick the one that will need the smallest increase
// in area to accomodate the new rectangle.  This will result in the
// least total area for the covering rectangles in the current node.
// In case of a tie, pick the one which was smaller before, to get
// the best resolution when searching.
RTREE_TEMPLATE
int RTREE_QUAL::PickBranch(const Rect *a_rect, Node *a_node) {

   #+end_src
** addbranch
   #+begin_src cpp
RTREE_TEMPLATE
bool RTREE_QUAL::AddBranch(const Branch *a_branch, Node *a_node,
                           Node **a_newNode) {
  ASSERT(a_branch);
  ASSERT(a_node);

  if (a_node->m_count < MAXNODES) // Split won't be necessary
  {
    a_node->m_branch[a_node->m_count] = *a_branch;
    ++a_node->m_count;

    return false;
  } else {
    ASSERT(a_newNode);

    SplitNode(a_node, a_branch, a_newNode);
    return true;
  }
}
   #+end_src


** TODO splitnote
   #+begin_src cpp
// Split a node.
// Divides the nodes branches and the extra one between two nodes.
// Old node is one of the new ones, and one really new one is created.
// Tries more than one method for choosing a partition, uses best result.
RTREE_TEMPLATE
void RTREE_QUAL::SplitNode(Node *a_node, const Branch *a_branch,
                           Node **a_newNode) {
  ASSERT(a_node);
  ASSERT(a_branch);

  // Could just use local here, but member or external is faster since it is
  // reused
  PartitionVars localVars;
  PartitionVars *parVars = &localVars;

  // Load all the branches into a buffer, initialize old node
  GetBranches(a_node, a_branch, parVars);

  // Find partition
  ChoosePartition(parVars, MINNODES);

  // Create a new node to hold (about) half of the branches
  *a_newNode = AllocNode();
  (*a_newNode)->m_level = a_node->m_level;

  // Put branches from buffer into 2 nodes according to the chosen partition
  a_node->m_count = 0;
  LoadNodes(a_node, *a_newNode, parVars);

  ASSERT((a_node->m_count + (*a_newNode)->m_count) == parVars->m_total);
}
   #+end_src

** node
   #+begin_src cpp
  struct Node {
    bool IsInternalNode() {
      return (m_level > 0);
    }                                        // Not a leaf, but a internal node
    bool IsLeaf() { return (m_level == 0); } // A leaf, contains data

   #+end_src

   
* other rtree libraries
  - https://mdds.readthedocs.io/en/latest/rtree.html#bulk-loading-data
  - https://kohei.us/2019/02/15/performance-benchmark-on-mdds-rtree/
  - https://gitlab.com/orcus/perf-test/blob/master/src/osm_load.cpp
    https://download.geofabrik.de/asia/japan/chubu-220321.osm.bz2
  - boost
* working with datasets?
** trying osm data
   - https://download.geofabrik.de/europe/greece-220320.osm.bz2
   - https://github.com/ben-strasser/fast-cpp-csv-parser
   #+begin_src sh
git clone https://github.com/osmzoso/osm2sqlite.git
time python3 ./osm2sqlite/osm2sqlite.py ./test/assets/greece-220320.osm ./test/assets/greece-220320.db # 9minutes omg

# or
(cd osm2sqlite; make ) # edited osm2sqlite: removed sqlite.c added -lsqlite3

time ./osm2sqlite/osm2sqlite ./test/assets/greece-220320.osm ./test/assets/greece-220320_2.db # rm

./osm2sqlite/osm2sqlite ./test/assets/greece-220320.osm ./test/assets/greece-220320_2.db --spatial-index
   #+end_src

   #+begin_src sh :session *rtree2*
(cd osm2sqlite; make )
sudo apt install libsqlite3-dev sqlite3
$(pkg-config --cflags --libs libsqlite3-dev)

dpkg -L sqlite3
dpkg -L libsqlite3-dev

litecli ./test/assets/greece-220320.db
sqlite3 ./test/assets/greece-220320.db
   #+end_src

   #+begin_src sql :session *rtree2*
SELECT way_tags.way_id
FROM way_tags limit 10;
     
SELECT way_tags.way_id, min(nodes.lat), max(nodes.lat), min(nodes.lon), max(nodes.lon)
FROM way_tags
LEFT JOIN way_nodes ON way_tags.way_id=way_nodes.way_id
LEFT JOIN nodes ON way_nodes.node_id=nodes.node_id
WHERE way_tags.key = 'highway'
limit 10;

select      way_tags.way_id
from      way_tags      ;	--


.tables

pragma table_info('node_tags');

pragma table_info('nodes');

pragma table_info('way_tags');

pragma table_info('way_nodes');

   #+end_src


  
*** querying osm
    #+begin_src sql :session *rtree2*
SELECT way_id FROM way_tags WHERE key = 'highway' limit 10;

    #+end_src

** natura etc
   https://www.eea.europa.eu/data-and-maps/data/natura-12
   https://www.eea.europa.eu/data-and-maps/data#c0=5&c11=&c5=all&b_start=0&c12=sites
   #+begin_src sh
cat ./test/assets/Natura2000_end2020_NATURA2000SITES.csv | awk -F, '{print $1}'

sqlite3
.mode csv

.import  ./test/assets/Natura2000_end2020_NATURA2000SITES.csv natura

pragma table_info('natura')

select SITENAME,LATITUDE,LONGITUDE from natura;

select count(*) from natura;

   #+end_src
* <2022-03-28 Mon> debugging handles version
** size 4 inserting
   - 0,0 :20
   - 
** bug 5x5: search returns duplicate ones
   Node 0 has branch (#3) Branch 6, which has child Node 0!
   #+begin_src text
Search --- Nid{0}
.. leaf
search Nid{0}#0Bid{3}{2, 0}
search Nid{0}#1Bid{4}{0, 0}
search Nid{0}#2Bid{5}{1, 0}
search Nid{0}#3Bid{6}{0, 1}
Bid{34} child Nid{0}
Search --- Nid{0}
.. leaf
search Nid{0}#0Bid{3}{2, 0}
search Nid{0}#1Bid{4}{0, 0}
search Nid{0}#2Bid{5}{1, 0}
search Nid{0}#3Bid{6}{0, 1}
   #+end_src


   aah
   - Nid{6}#1Bid{34} child Nid{0}
   - Nid{6}#2Bid{34} child Nid{0}
     so.. node 6 has branch #1 and #2.. the same branch!

     aha! removal was buggy
* <2022-04-04 Mon> just rewrite..
  - http://postgis.net/docs/support/rtree.pdf
  - https://github.com/aled/jsi
    seems close to the paper, LGLPL. Good for reference, how it follows the paper
* <2022-04-07 Thu> debugging
** scratch
   #+begin_quote
 +++ insert Eid{188} Did{63} {6, 3}
 insert split Eid{188}Did{63} n Nid{12}, nn Nid{14} traversal {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 --- adjust tree n Nid{12} height 0 nn Nid{14} Eid{188} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 insert split Eid{197}Did{4294967295} n Nid{10}, nn Nid{15} traversal {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 --- adjust tree n Nid{10} height 1 nn Nid{15} Eid{197} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
	 made entry Eid{206} child nn Nid{15}, inserting
 insert plain : Eid{206}Did{4294967295} Nid{10}
 --- adjust tree n Nid{10} height 1 nn Nid{4294967295} Eid{206} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
  .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{4294967295}
  .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{15}
	 made entry Eid{207} child nn Nid{15}, inserting
 insert plain : Eid{207}Did{4294967295} Nid{2}
 --- adjust tree n Nid{2} height 1 nn Nid{4294967295} Eid{207} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
  .. adjust tree Parent{Nid{2},Eid{4294967295}} nn Nid{4294967295}
 +++ insert Eid{208} Did{64} {6, 4}

   #+end_quote

   with copy of traversal for adjust_tree
   #+begin_quote
 +++ insert Eid{188} Did{63} {6, 3}
 insert split Eid{188}Did{63} n Nid{12}, nn Nid{14} traversal {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 --- adjust tree n Nid{12} height 0 nn Nid{14} Eid{188} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 insert split Eid{197}Did{4294967295} n Nid{10}, nn Nid{15} traversal {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 --- adjust tree n Nid{10} height 1 nn Nid{15} Eid{197} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
	 made entry Eid{206} child nn Nid{15}, inserting
 insert plain : Eid{206}Did{4294967295} Nid{10}
 --- adjust tree n Nid{10} height 1 nn Nid{4294967295} Eid{206} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
  .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{4294967295}
  .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{15}
	 made entry Eid{207} child nn Nid{15}, inserting
 insert plain : Eid{207}Did{4294967295} Nid{2}
 --- adjust tree n Nid{2} height 1 nn Nid{4294967295} Eid{207} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
  .. adjust tree Parent{Nid{2},Eid{4294967295}} nn Nid{4294967295}

   #+end_quote

   no change. I think m_traversal is modified only on public version of insert (choose_leaf)


   traversal_offset
   #+begin_quote
 +++ insert Eid{188} Did{63} {6, 3}
 insert split Eid{188}Did{63} n Nid{12}, nn Nid{14} traversal {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 --- adjust tree n Nid{12} height 0 nn Nid{14} Eid{188} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 insert split Eid{197}Did{4294967295} n Nid{10}, nn Nid{15} traversal {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 --- adjust tree n Nid{10} height 1 nn Nid{15} Eid{197} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
	 made entry Eid{206} child nn Nid{15}, inserting
 insert plain : Eid{206}Did{4294967295} Nid{10}
 --- adjust tree n Nid{10} height 1 nn Nid{4294967295} Eid{206} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
  .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{4294967295}
  .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{15}
	 made entry Eid{207} child nn Nid{15}, inserting
 insert plain : Eid{207}Did{4294967295} Nid{2}
 --- adjust tree n Nid{2} height 1 nn Nid{4294967295} Eid{207} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
  .. adjust tree Parent{Nid{2},Eid{4294967295}} nn Nid{4294967295}
 +++ insert Eid{208} Did{64} {6, 4}

   #+end_quote
** offset
   #+begin_quote
+++ insert Eid{188} Did{63} {6, 3}
insert split Eid{188}Did{63} n Nid{12}, nn Nid{14} traversal {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
  traversal with offset Traversal0{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
--- adjust tree n Nid{12} height 0 nn Nid{14} Eid{188} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 traversal with offset Traversal0{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
insert split Eid{197}Did{4294967295} n Nid{10}, nn Nid{15} traversal {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
  traversal with offset Traversal1{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, }
--- adjust tree n Nid{10} height 1 nn Nid{15} Eid{197} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 traversal with offset Traversal1{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, }
	made entry Eid{206} child nn Nid{15}, inserting
insert plain : Eid{206}Did{4294967295} Nid{10}
--- adjust tree n Nid{10} height 1 nn Nid{4294967295} Eid{206} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 traversal with offset Traversal2{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, }
 .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{4294967295}
 .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{15}
	made entry Eid{207} child nn Nid{15}, inserting
insert plain : Eid{207}Did{4294967295} Nid{2}
--- adjust tree n Nid{2} height 1 nn Nid{4294967295} Eid{207} parents {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
 traversal with offset Traversal1{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, }
 .. adjust tree Parent{Nid{2},Eid{4294967295}} nn Nid{4294967295}

   #+end_quote

   #+begin_quote
+++ insert Eid{188} Did{63} {6, 3}
internal insert Nid{12}Eid{188}Did{63} Traversal0{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
.. split_and_insert 
--- adjust tree n Nid{12} height 0 nn Nid{14} Eid{188}Traversal0{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, Parent{Nid{12},Eid{188}}}
internal insert Nid{10}Eid{197}Did{4294967295} Traversal1{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, }
.. split_and_insert 
--- adjust tree n Nid{10} height 1 nn Nid{15} Eid{197}Traversal1{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, }
	made entry Eid{206} child nn Nid{15}, inserting
internal insert Nid{10}Eid{206}Did{4294967295} Traversal2{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, }
.. plain_insert
--- adjust tree n Nid{10} height 1 nn Nid{4294967295} Eid{206}Traversal2{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, }
 .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{4294967295}
 .. adjust tree Parent{Nid{10},Eid{141}} nn Nid{15}
	made entry Eid{207} child nn Nid{15}, inserting
internal insert Nid{2}Eid{207}Did{4294967295} Traversal1{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, }
.. plain_insert
--- adjust tree n Nid{2} height 1 nn Nid{4294967295} Eid{207}Traversal1{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{141}}, Parent{Nid{12},Eid{169}}, }
 .. adjust tree Parent{Nid{2},Eid{4294967295}} nn Nid{4294967295}

   #+end_quote

   #+begin_quote
+++ insert Eid{197} Did{63} {6, 3}
internal insert Nid{13}Eid{197}Did{63} Traversal0{Parent{Nid{11},Eid{4294967295}}, Parent{Nid{10},Eid{150}}, Parent{Nid{13},Eid{178}}, Parent{Nid{13},Eid{197}}}
.. split_and_insert 
--- adjust tree n Nid{13} height 0 nn Nid{15} Eid{197}Traversal0{Parent{Nid{11},Eid{4294967295}}, Parent{Nid{10},Eid{150}}, Parent{Nid{13},Eid{178}}, Parent{Nid{13},Eid{197}}}
	made entry Eid{206} child nn Nid{15}, inserting
internal insert Nid{10}Eid{206}Did{4294967295} Traversal3{Parent{Nid{11},Eid{4294967295}}, }
.. split_and_insert 
--- adjust tree n Nid{10} height 1 nn Nid{16} Eid{206}Traversal3{Parent{Nid{11},Eid{4294967295}}, }
internal insert Nid{11}Eid{215}Did{4294967295} Traversal4{}
.. plain_insert
--- adjust tree n Nid{11} height 2 nn Nid{4294967295} Eid{215}Traversal4{}
 .. adjust tree Parent{Nid{11},Eid{4294967295}} nn Nid{4294967295}
 .. adjust tree Parent{Nid{10},Eid{150}} nn Nid{16}
internal insert Nid{11}Eid{216}Did{4294967295} Traversal4{}
.. plain_insert
--- adjust tree n Nid{11} height 2 nn Nid{4294967295} Eid{216}Traversal4{}
 .. adjust tree Parent{Nid{11},Eid{4294967295}} nn Nid{4294967295}

   #+end_quote
** notes
   data id 40, 63 is duplicate. right after insertion of 6, 3 (data id 63)
   node id 16 is duplicate, which has height 1 (so its children are duplicate

   there's sth wrong about insert & adjust_tree. who is responsible of what?

   #+begin_quote
+++ insert Eid{197} Did{63} {6, 3}
>>> internal insert Nid{13}Eid{197}Did{63} Traversal0{Parent{Nid{11},Eid{4294967295}}, Parent{Nid{10},Eid{150}}, Parent{Nid{13},Eid{178}}, Parent{Nid{13},Eid{197}}}
    split_and_insert 
    adjust_tree, nn Nid{15}
>>> adjust tree n Nid{13} height 0 nn Nid{15} Eid{197}Traversal0{Parent{Nid{11},Eid{4294967295}}, Parent{Nid{10},Eid{150}}, Parent{Nid{13},Eid{178}}, Parent{Nid{13},Eid{197}}}
.. inserting nn, made entry Eid{206} child nn Nid{15}
>>> internal insert Nid{10}Eid{206}Did{4294967295} Traversal3{Parent{Nid{11},Eid{4294967295}}, }
    split_and_insert 
    adjust_tree, nn Nid{16}
>>> adjust tree n Nid{10} height 1 nn Nid{16} Eid{206}Traversal3{Parent{Nid{11},Eid{4294967295}}, }
.. inserting nn, made entry Eid{215} child nn Nid{16}
>>> internal insert Nid{11}Eid{215}Did{4294967295} Traversal4{}
    plain_insert
    adjust_tree, nn Nid{4294967295}
>>> adjust tree n Nid{11} height 2 nn Nid{4294967295} Eid{215}Traversal4{}
<<< adjust tree
<<< internal_insert, nn Nid{4294967295}
<<< adjust tree
<<< internal_insert, nn Nid{16}
.. inserting nn, made entry Eid{216} child nn Nid{16}
>>> internal insert Nid{11}Eid{216}Did{4294967295} Traversal4{}
    plain_insert
    adjust_tree, nn Nid{4294967295}
>>> adjust tree n Nid{11} height 2 nn Nid{4294967295} Eid{216}Traversal4{}
<<< adjust tree
<<< internal_insert, nn Nid{4294967295}
<<< adjust tree
<<< internal_insert, nn Nid{15}
Node Nid{16} already in the container
   #+end_quote
** <2022-04-08 Fri> debug
   calling adjust_tree only from public insert, not from internal insert
   <2022-04-08 Fri 16:38> fixed?
   
   5x5
   #+begin_quote
+++ insert Eid{80} Did{27} {4, 3}
>>> internal insert Nid{4}Eid{80}Did{27} Traversal0{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{4},Eid{64}}, Parent{Nid{4},Eid{80}}}
:: distributed entries
<Node id="4" height="0" children="5" >
 <Entry id="16" rect_id="22" bounds="{1, 2}...{1, 2}" >
 <Data id="8" data="{1, 2}"/>
 </Entry>
 <Entry id="35" rect_id="41" bounds="{1, 3}...{1, 3}" >
 <Data id="9" data="{1, 3}"/>
 </Entry>
 <Entry id="49" rect_id="55" bounds="{2, 2}...{2, 2}" >
 <Data id="14" data="{2, 2}"/>
 </Entry>
 <Entry id="79" rect_id="85" bounds="{4, 2}...{4, 2}" >
 <Data id="26" data="{4, 2}"/>
 </Entry>
 <Entry id="80" rect_id="86" bounds="{4, 3}...{4, 3}" >
 <Data id="27" data="{4, 3}"/>
 </Entry>
</Node>

<Node id="6" height="0" children="4" >
 <Entry id="67" rect_id="73" bounds="{3, 5}...{3, 5}" >
 <Data id="23" data="{3, 5}"/>
 </Entry>
 <Entry id="66" rect_id="72" bounds="{3, 4}...{3, 4}" >
 <Data id="22" data="{3, 4}"/>
 </Entry>
 <Entry id="55" rect_id="61" bounds="{3, 2}...{3, 2}" >
 <Data id="20" data="{3, 2}"/>
 </Entry>
 <Entry id="65" rect_id="71" bounds="{3, 3}...{3, 3}" >
 <Data id="21" data="{3, 3}"/>
 </Entry>
</Node>

    split_and_insert 
    adjust_tree, nn Nid{6}
<<< internal_insert, nn Nid{6}
>>> adjust tree n Nid{4} height 0 nn Nid{6} Eid{80}Traversal0{Parent{Nid{2},Eid{4294967295}}, Parent{Nid{4},Eid{64}}, Parent{Nid{4},Eid{80}}}
.. inserting nn, made entry Eid{89} child nn Nid{6}
>>> internal insert Nid{2}Eid{89}Did{4294967295} Traversal3{}
    plain_insert
    adjust_tree, nn Nid{4294967295}
<<< internal_insert, nn Nid{4294967295}
<<< adjust tree

   #+end_quote
* perfomance
** no randomized grid
   #+begin_quote
-------------------------------------------------------------------------------
200x2d drtree
-------------------------------------------------------------------------------
../test/test.cpp:296
...............................................................................

../test/test.cpp:303: 
warning:
  init took 67ms

../test/test.cpp:320: warning:
  search x10000 13 ms 

../test/test.cpp:335: warning:
  copy took 8 ms 

-------------------------------------------------------------------------------
200x2d rtree
-------------------------------------------------------------------------------
../test/test.cpp:345
...............................................................................

../test/test.cpp:354: warning:
  init size 200 took 77ms

../test/test.cpp:370: warning:
  search x10000 11 ms 

../test/test.cpp:385: warning:
  copy took 3 ms 

-------------------------------------------------------------------------------
200x2d drtree3
-------------------------------------------------------------------------------
../test/test.cpp:391
...............................................................................

../test/test.cpp:396: warning:
  init size 200 took 68ms

../test/test.cpp:417: warning:
  search x10000 7 ms 

../test/test.cpp:422: warning:
  copy took 2 ms 

-------------------------------------------------------------------------------
200x2d aod::rtree
-------------------------------------------------------------------------------
../test/test.cpp:429
...............................................................................

../test/test.cpp:434: warning:
  init size 200 took 54ms

../test/test.cpp:455: warning:
  search x10000 11 ms 

../test/test.cpp:460: warning:
  copy took 1 ms 

   #+end_quote
** randomized grid
   #+begin_quote
-------------------------------------------------------------------------------
200x2d drtree
-------------------------------------------------------------------------------
../test/test.cpp:296
...............................................................................

../test/test.cpp:303: 
warning:
  init took 81ms

../test/test.cpp:320: warning:
  search x10000 13 ms 

../test/test.cpp:335: warning:
  copy took 9 ms 

-------------------------------------------------------------------------------
200x2d rtree
-------------------------------------------------------------------------------
../test/test.cpp:345
...............................................................................

../test/test.cpp:354: warning:
  init size 200 took 83ms

../test/test.cpp:370: warning:
  search x10000 17 ms 

../test/test.cpp:385: warning:
  copy took 6 ms 

-------------------------------------------------------------------------------
200x2d drtree3
-------------------------------------------------------------------------------
../test/test.cpp:391
...............................................................................

../test/test.cpp:396: warning:
  init size 200 took 124ms

../test/test.cpp:417: warning:
  search x10000 18 ms 

../test/test.cpp:422: warning:
  copy took 5 ms 

-------------------------------------------------------------------------------
200x2d aod::rtree
-------------------------------------------------------------------------------
../test/test.cpp:429
...............................................................................

../test/test.cpp:434: warning:
  init size 200 took 91ms

../test/test.cpp:455: warning:
  search x10000 16 ms 

../test/test.cpp:460: warning:
  copy took 3 ms 

   #+end_quote
* <2022-04-09 Sat> removals
** 8x8
   #+begin_quote
>>> condense tree
    {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{3},Eid{16}}}
    {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{1},Eid{10}}}
    {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{6},Eid{41}}}
    {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{7},Eid{45}}}
    {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{53}}, Parent{Nid{8},Eid{48}}}
    {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{53}}, Parent{Nid{0},Eid{9}}}
    {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{53}}, Parent{Nid{9},Eid{52}}}
    {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{10},Eid{53}}, Parent{Nid{4},Eid{26}}}
    {Parent{Nid{2},Eid{4294967295}}, Parent{Nid{12},Eid{69}}}
<<< condense tree
   #+end_quote
** deletion algorithm
   http://albert-jan.yzelman.net/PDFs/yzelman07b.pdf

   #+begin_quote
Algorithm A.3.3 Basic R-tree Deletion Algorithm
This algorithm deletes an object o, stored at the tree with root r.
Delete(r, o):
1: Find the leaf v which contains o
2: Remove o from v
3: Let S be an empty set
4: X = v
5: while X != r do
  6: if X has less than m children then
    7: Add all children of X to S
    8: Remove X from its parent p
    9: X = p
  10: end if
11: end while
12: Re-insert all entries in S to the R-tree defined by r
13: if X has only one child c then {At this point, X is the root}
  14: Let X = c
15: end if
   #+end_quote
** DONE <2022-04-09 Sat> removal seems to work
   - [X] fix entry bounding rect
* r-star tree?
  https://tildesites.bowdoin.edu/~ltoma/teaching/cs340/spring08/Papers/Rstar3.pdf
* TODO compare tree with Superliminal
  add to_xml functionality, and compare!
