#+PROPERTY: header-args:sh :session *rtree*

* <2022-03-10 Thu> adding tests & refactoring
  #+begin_src sh
meson wrap search catch
meson wrap info catch2

meson wrap install catch2

meson configure build -Dtest=true
  #+end_src

  vector of vectors & reserve: https://stackoverflow.com/questions/16220915/how-to-reserve-memory-for-vector-of-vector

  used https://github.com/hebaishi/easy-cpp-print for printing out std::vector, std::vector<std::vector<t>> etc!
  no licence, oh well


** printing out vectors etc
   or just https://github.com/hebaishi/easy-cpp-print 
   #+begin_src cpp
template<typename T>
void print_vec(std::ostream &os, const std::vector<T> &vec) {
  auto size = vec.size();
  os << "{";
  for(auto i=0; i < size - 1; i++) {
    os << vec[i] << ",";
  }
  if(size > 0) {
    os << vec[size-1];
  }
  os << "}";
}

std::ostream &operator<<(std::ostream &os, const std::vector<int> &vec) {
  print_vec<int>(os, vec);
  return os;
}

std::ostream &operator<<(std::ostream &os, const std::vector<double> &vec) {
  print_vec<double>(os, vec);
  return os;
}

std::ostream &operator<<(std::ostream &os, const std::vector<std::vector<double>> &vec) {
  cerr << "{";
  for(const auto& x : vec) print_vec<double>(os, x);
  cerr << "}" << endl;
  return os;
}
   #+end_src

** test: sorting vector and equality
   #+begin_src cpp
std::sort(found.begin(), found.end(),
          [](const Type &a, const Type &b) {
            const auto size = std::min(a.size(), b.size());
            for(auto i=0; i < size; i++) {
              if ( a[i] < b[i]) {
                return true;
              }
            }
            return false;
          });
   #+end_src

   
** making grid
   #+begin_src cpp
std::vector<std::array<double, DIMS>> make_grid_template(int length)
{
  std::vector<std::array<double, DIMS>> res;
  int size = pow(length, DIMS);
  res.reserve(size);
  for (int i = 0; i < size; i++)
  {
    auto &el = res[i];
    for (int dim = 0; dim < DIMS; dim++)
    {
      int denum = pow(length, dim);
      int x = (int)(i / denum) % length;
      int mod = x % length;
      el[DIMS - dim - 1] = mod;
    }
    cerr << "  ";
    for(int i=0; i< DIMS; i++) {
      cerr << el[i] << ",";
    }
    cerr << endl;
  }

  return res;
}

std::vector<std::vector<double>> make_grid(int length, int dims = 2)
{
  std::vector<std::vector<double>> res;
  int size = pow(length, dims);
  res.resize(size);
  for (int i = 0; i < size; i++)
  {
    auto &el = res[i];
    el.resize(dims); // resize or reserve? kind of same?
    for (int dim = 0; dim < dims; dim++)
    {
      int denum = pow(length, dim);
      int x = (int)(i / denum) % length;
      int mod = x % length;
      el[dims - dim - 1] = mod;
    }
    cerr << "  ";
    for(int i=0; i< dims; i++) {
      cerr << el[i] << ",";
    }
    cerr << endl;
  }

  return res;
}
   #+end_src

* <2022-03-13 Sun> runtime only size
  started with using std::vector (for some reason) to store the Rects.. the result was timing ~ *10.
  Ofourse that was the first iteration, and then wanted to use some allocator:
  - a node has MAXNODES (default 8) branches (TODO fix this naming)
  - each branch has a rect: a rect is a vector of DIMS elements

  thus, I could preallocate =MAXNODES*(sizeof(Branch) + DIMS*sizeof(double))= , and then it can be used by all the branches (placement new) & from their Rects (new double[DIMS])

  <2022-03-13 Sun> fixes some issues: still though completely oblivious wrt move semantics, copy assignment etc..

  also see https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/

  
* <2022-03-15 Tue> profiling
  https://profiler.firefox.com/
  callgrind (a heap profiler called massif)
  
  #+begin_src sh
# pprof -web ./build/
sudo sh -c 'echo 1 >/proc/sys/kernel/perf_event_paranoid'

perf record -F 99 -g ./build/test/run-tests [benchmark]

perf script -F +pid > perf_ff.perf

perf

sudo apt install linux-tools-5.13.0-30-generic

sudo apt install linux-cloud-tools-generic

  #+end_src

  #+begin_src sh
rm -rf callgrind.out.*
valgrind --tool=callgrind ./build/test/run-tests "benchmark template version"
valgrind --tool=callgrind ./build/test/run-tests "benchmark"

valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose  ./build/test/run-tests # "benchmark"
  #+end_src

* <2022-03-16 Wed> overloading new etc
  - https://stackoverflow.com/questions/4638429/c-placement-new-vs-overloading-new
  - https://stackoverflow.com/questions/58225405/c-14-overload-new-operator-to-allocate-more-continuous-space-than-objects-s
    static_cast??
    https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used

    https://stackoverflow.com/questions/12215029/c-placement-new-collides-with-own-new-overload?rq=1

    https://bytes.com/topic/c/answers/583571-overriding-placement-new-correctly
    nice answers (quoting some c++ books)

    https://www.amazon.de/Modern-Generic-Programming-Patterns-Applied/dp/0201704315
    has a chapter for allocations
    as seen https://eli.thegreenplace.net/2011/02/17/the-many-faces-of-operator-new-in-c

* <2022-03-17 Thu> dynamic rtree: drtree
  - attempt some optimizations also to the existing library
  - compare vs the dynamic one drtree
  - compare cost of using a high MAXDIMS even when using smaller ones (as I had it)
    - memory used?


  - for 200x200 in dynamic version:
    ==69281==   total heap usage: 119,454 allocs, 119,454 frees, 10,671,421 bytes allocated
  - rtree with dimesions of 4:
    ==69400==   total heap usage: 213,955 allocs, 213,955 frees, 11,674,285 bytes allocated
    also had errors?
    ==69400== Invalid read of size 8
  - rtree with dimensions of 2:
    ==69842==   total heap usage: 218,824 allocs, 218,824 frees, 9,626,709 bytes allocated
    

  
* <2022-03-20 Sun> renamed to drtree, some mods
  200x2d (init only)
  was:
  total heap usage: 144,515 allocs, 144,515 frees, 11,283,940 bytes allocated
  
  after removing bool needs_cleanup (now constructing rect only with allocator):
  total heap usage: 119,490 allocs, 119,490 frees, 10,676,298 bytes allocated

  
** trying out using one array for the rect, offsetting index for min(low) vs max(high)
   - RectSphericalVolume was 301,312,719
   - combine_rects: 265,608,658
     
   - oh.. with refactor it's worse! 335,506,434
   - two arrays, but =double* const m_min=: 

    RTree (template version) has
     - RectSphericalVolume 268,915,845
     - CombineRect 256,292,035

** godbolt
   #+begin_src c++
#include <iostream>

using std::cout;

struct Rect {
    const int dims = 2;
    double low[2];
    double high[2];
    double volume() {
        double res = 0;
        for(int i=0; i<dims; i++) {
            res *= high[i] - low[i];
        }
        return res;
    }
};

struct Rect2 {
    const int dims;
    double* low;
    double* high;
    Rect2(int dims) :dims{dims} {
        low = new double[dims];
        high = new double[dims];
    }
    double volume() {
        double res = 0;
        for(int i=0; i<dims; i++) {
            res *= high[i] - low[i];
        }
        return res;
    }
};

double calc_volume(Rect* rect) {
    double res = 0;
        for(int i=0; i<rect->dims; i++) {
            res *= rect->high[i] - rect->low[i];
        }
    return res;
}

double calc_volume2(Rect2* rect) {
    double res = 0;
        for(int i=0; i<rect->dims; i++) {
            res *= rect->high[i] - rect->low[i];
        }
    return res;
}

int main() {
    Rect r;
    Rect2 r2(2);
    // double vol = r.volume();
    // double vol = calc_volume(&r);
    double vol = r2.volume();
    cout << "volume " << vol;

}
   #+end_src

   
* <2022-03-23 Wed> drtree2: trying the idea of handles vs pointers
  - <2022-03-23 Wed> MVP of having Rect being a handle, storing ALL rects in one std::vector
    the idea is that copy ctor for the rtree will be much faster
* rtree resources
  - https://www.cse.cuhk.edu.hk/~taoyf/course/infs4205/lec/rtree.pdf
  - https://livebook.manning.com/concept/algorithms/r-tree
  - http://www.mathcs.emory.edu/~cheung/Courses/554/Syllabus/3-index/R-tree.html
* terminology
  - a node has N branches (N=MAXNODES)
    - storing m_count for how many branches it stores
  - a branch is:
    - rect
    - data
    - Node* child
  - level 0 is for leafs? root has level > 0
    hmm I think level should be called =height= in this library


** insertion
   Insert(const ELEMTYPE *a_min, const ELEMTYPE *a_max, const DATATYPE &a_dataId)
   - Initializes a branch
   - calls InsertRect

   InsertRect(const Branch &a_branch, Node **a_root, a_level): called with 0 level
   inserts a rectangle into the data structure
   - InsertRectRec(const Branch &a_branch, Node **a_root, a_level
     (recursive)
     #+begin_src cpp
  if (InsertRectRec(a_branch, *a_root, &newNode, a_level)) // Root split
  {
    // Grow tree taller and new root
    Node *newRoot = AllocNode();
    newRoot->m_level = (*a_root)->m_level + 1;

    Branch branch;
     #+end_src
     returns true ifnode was split. if not, fine!, nothing extra to do


   InsertRectRec
   #+begin_src cpp
  // recurse until we reach the correct level for the new record. data records
  // will always be called with a_level == 0 (leaf)
  if (a_node->m_level > a_level) {
    // Still above level for insertion, go down tree recursively
    Node *otherNode;

    // find the optimal branch for this record
    int index = PickBranch(&a_branch.m_rect, a_node);


   #+end_src

   
*** TODO InsertRect: do not get argument Node**
    - return =std::optional<nid>= 
** pick branch
   #+begin_src cpp
// Pick a branch.  Pick the one that will need the smallest increase
// in area to accomodate the new rectangle.  This will result in the
// least total area for the covering rectangles in the current node.
// In case of a tie, pick the one which was smaller before, to get
// the best resolution when searching.
RTREE_TEMPLATE
int RTREE_QUAL::PickBranch(const Rect *a_rect, Node *a_node) {

   #+end_src
** addbranch
   #+begin_src cpp
RTREE_TEMPLATE
bool RTREE_QUAL::AddBranch(const Branch *a_branch, Node *a_node,
                           Node **a_newNode) {
  ASSERT(a_branch);
  ASSERT(a_node);

  if (a_node->m_count < MAXNODES) // Split won't be necessary
  {
    a_node->m_branch[a_node->m_count] = *a_branch;
    ++a_node->m_count;

    return false;
  } else {
    ASSERT(a_newNode);

    SplitNode(a_node, a_branch, a_newNode);
    return true;
  }
}
   #+end_src


** TODO splitnote
   #+begin_src cpp
// Split a node.
// Divides the nodes branches and the extra one between two nodes.
// Old node is one of the new ones, and one really new one is created.
// Tries more than one method for choosing a partition, uses best result.
RTREE_TEMPLATE
void RTREE_QUAL::SplitNode(Node *a_node, const Branch *a_branch,
                           Node **a_newNode) {
  ASSERT(a_node);
  ASSERT(a_branch);

  // Could just use local here, but member or external is faster since it is
  // reused
  PartitionVars localVars;
  PartitionVars *parVars = &localVars;

  // Load all the branches into a buffer, initialize old node
  GetBranches(a_node, a_branch, parVars);

  // Find partition
  ChoosePartition(parVars, MINNODES);

  // Create a new node to hold (about) half of the branches
  *a_newNode = AllocNode();
  (*a_newNode)->m_level = a_node->m_level;

  // Put branches from buffer into 2 nodes according to the chosen partition
  a_node->m_count = 0;
  LoadNodes(a_node, *a_newNode, parVars);

  ASSERT((a_node->m_count + (*a_newNode)->m_count) == parVars->m_total);
}
   #+end_src

** node
   #+begin_src cpp
  struct Node {
    bool IsInternalNode() {
      return (m_level > 0);
    }                                        // Not a leaf, but a internal node
    bool IsLeaf() { return (m_level == 0); } // A leaf, contains data

   #+end_src

   
* other rtree libraries
  - https://mdds.readthedocs.io/en/latest/rtree.html#bulk-loading-data
  - https://kohei.us/2019/02/15/performance-benchmark-on-mdds-rtree/
  - https://gitlab.com/orcus/perf-test/blob/master/src/osm_load.cpp
    https://download.geofabrik.de/asia/japan/chubu-220321.osm.bz2
  - boost
* working with datasets?
** trying osm data
   - https://download.geofabrik.de/europe/greece-220320.osm.bz2
   - https://github.com/ben-strasser/fast-cpp-csv-parser
   #+begin_src sh
git clone https://github.com/osmzoso/osm2sqlite.git
time python3 ./osm2sqlite/osm2sqlite.py ./test/assets/greece-220320.osm ./test/assets/greece-220320.db # 9minutes omg

# or
(cd osm2sqlite; make ) # edited osm2sqlite: removed sqlite.c added -lsqlite3

time ./osm2sqlite/osm2sqlite ./test/assets/greece-220320.osm ./test/assets/greece-220320_2.db # rm

./osm2sqlite/osm2sqlite ./test/assets/greece-220320.osm ./test/assets/greece-220320_2.db --spatial-index
   #+end_src

   #+begin_src sh :session *rtree2*
(cd osm2sqlite; make )
sudo apt install libsqlite3-dev sqlite3
$(pkg-config --cflags --libs libsqlite3-dev)

dpkg -L sqlite3
dpkg -L libsqlite3-dev

litecli ./test/assets/greece-220320.db
sqlite3 ./test/assets/greece-220320.db
   #+end_src

   #+begin_src sql :session *rtree2*
SELECT way_tags.way_id
FROM way_tags limit 10;
     
SELECT way_tags.way_id, min(nodes.lat), max(nodes.lat), min(nodes.lon), max(nodes.lon)
FROM way_tags
LEFT JOIN way_nodes ON way_tags.way_id=way_nodes.way_id
LEFT JOIN nodes ON way_nodes.node_id=nodes.node_id
WHERE way_tags.key = 'highway'
limit 10;

select      way_tags.way_id
from      way_tags      ;	--


.tables

pragma table_info('node_tags');

pragma table_info('nodes');

pragma table_info('way_tags');

pragma table_info('way_nodes');

   #+end_src


  
*** querying osm
    #+begin_src sql :session *rtree2*
SELECT way_id FROM way_tags WHERE key = 'highway' limit 10;

    #+end_src

** natura etc
   https://www.eea.europa.eu/data-and-maps/data/natura-12
   https://www.eea.europa.eu/data-and-maps/data#c0=5&c11=&c5=all&b_start=0&c12=sites
   #+begin_src sh
cat ./test/assets/Natura2000_end2020_NATURA2000SITES.csv | awk -F, '{print $1}'

sqlite3
.mode csv

.import  ./test/assets/Natura2000_end2020_NATURA2000SITES.csv natura

pragma table_info('natura')

select SITENAME,LATITUDE,LONGITUDE from natura;

select count(*) from natura;

   #+end_src
* <2022-03-28 Mon> debugging handles version
** size 4 inserting
   - 0,0 :20
   - 
** bug 5x5: search returns duplicate ones
   Node 0 has branch (#3) Branch 6, which has child Node 0!
   #+begin_src text
Search --- Nid{0}
.. leaf
search Nid{0}#0Bid{3}{2, 0}
search Nid{0}#1Bid{4}{0, 0}
search Nid{0}#2Bid{5}{1, 0}
search Nid{0}#3Bid{6}{0, 1}
Bid{34} child Nid{0}
Search --- Nid{0}
.. leaf
search Nid{0}#0Bid{3}{2, 0}
search Nid{0}#1Bid{4}{0, 0}
search Nid{0}#2Bid{5}{1, 0}
search Nid{0}#3Bid{6}{0, 1}
   #+end_src


   aah
   - Nid{6}#1Bid{34} child Nid{0}
   - Nid{6}#2Bid{34} child Nid{0}
     so.. node 6 has branch #1 and #2.. the same branch!

     aha! removal was buggy
* <2022-04-04 Mon> just rewrite..
  - http://postgis.net/docs/support/rtree.pdf
  - https://github.com/aled/jsi
    seems close to the paper, LGLPL. Good for reference, how it follows the paper
