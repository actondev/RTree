#+PROPERTY: header-args:sh :session *rtree*

* <2022-03-10 Thu> adding tests & refactoring
  #+begin_src sh
meson wrap search catch
meson wrap info catch2

meson wrap install catch2

meson configure build -Dtest=true
  #+end_src

  vector of vectors & reserve: https://stackoverflow.com/questions/16220915/how-to-reserve-memory-for-vector-of-vector

  used https://github.com/hebaishi/easy-cpp-print for printing out std::vector, std::vector<std::vector<t>> etc!
  no licence, oh well


** printing out vectors etc
   or just https://github.com/hebaishi/easy-cpp-print 
   #+begin_src cpp
template<typename T>
void print_vec(std::ostream &os, const std::vector<T> &vec) {
  auto size = vec.size();
  os << "{";
  for(auto i=0; i < size - 1; i++) {
    os << vec[i] << ",";
  }
  if(size > 0) {
    os << vec[size-1];
  }
  os << "}";
}

std::ostream &operator<<(std::ostream &os, const std::vector<int> &vec) {
  print_vec<int>(os, vec);
  return os;
}

std::ostream &operator<<(std::ostream &os, const std::vector<double> &vec) {
  print_vec<double>(os, vec);
  return os;
}

std::ostream &operator<<(std::ostream &os, const std::vector<std::vector<double>> &vec) {
  cerr << "{";
  for(const auto& x : vec) print_vec<double>(os, x);
  cerr << "}" << endl;
  return os;
}
   #+end_src

** test: sorting vector and equality
   #+begin_src cpp
std::sort(found.begin(), found.end(),
          [](const Type &a, const Type &b) {
            const auto size = std::min(a.size(), b.size());
            for(auto i=0; i < size; i++) {
              if ( a[i] < b[i]) {
                return true;
              }
            }
            return false;
          });
   #+end_src

   
** making grid
   #+begin_src cpp
std::vector<std::array<double, DIMS>> make_grid_template(int length)
{
  std::vector<std::array<double, DIMS>> res;
  int size = pow(length, DIMS);
  res.reserve(size);
  for (int i = 0; i < size; i++)
  {
    auto &el = res[i];
    for (int dim = 0; dim < DIMS; dim++)
    {
      int denum = pow(length, dim);
      int x = (int)(i / denum) % length;
      int mod = x % length;
      el[DIMS - dim - 1] = mod;
    }
    cerr << "  ";
    for(int i=0; i< DIMS; i++) {
      cerr << el[i] << ",";
    }
    cerr << endl;
  }

  return res;
}

std::vector<std::vector<double>> make_grid(int length, int dims = 2)
{
  std::vector<std::vector<double>> res;
  int size = pow(length, dims);
  res.resize(size);
  for (int i = 0; i < size; i++)
  {
    auto &el = res[i];
    el.resize(dims); // resize or reserve? kind of same?
    for (int dim = 0; dim < dims; dim++)
    {
      int denum = pow(length, dim);
      int x = (int)(i / denum) % length;
      int mod = x % length;
      el[dims - dim - 1] = mod;
    }
    cerr << "  ";
    for(int i=0; i< dims; i++) {
      cerr << el[i] << ",";
    }
    cerr << endl;
  }

  return res;
}
   #+end_src

* <2022-03-13 Sun> runtime only size
  started with using std::vector (for some reason) to store the Rects.. the result was timing ~ *10.
  Ofourse that was the first iteration, and then wanted to use some allocator:
  - a node has MAXNODES (default 8) branches (TODO fix this naming)
  - each branch has a rect: a rect is a vector of DIMS elements

  thus, I could preallocate =MAXNODES*(sizeof(Branch) + DIMS*sizeof(double))= , and then it can be used by all the branches (placement new) & from their Rects (new double[DIMS])

  <2022-03-13 Sun> fixes some issues: still though completely oblivious wrt move semantics, copy assignment etc..

  also see https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/

  
* <2022-03-15 Tue> profiling
  https://profiler.firefox.com/
  callgrind (a heap profiler called massif)
  
  #+begin_src sh
# pprof -web ./build/
sudo sh -c 'echo 1 >/proc/sys/kernel/perf_event_paranoid'

perf record -F 99 -g ./build/test/run-tests [benchmark]

perf script -F +pid > perf_ff.perf

perf

sudo apt install linux-tools-5.13.0-30-generic

sudo apt install linux-cloud-tools-generic

  #+end_src

  #+begin_src sh
rm -rf callgrind.out.*
valgrind --tool=callgrind ./build/test/run-tests "benchmark template version"
valgrind --tool=callgrind ./build/test/run-tests "benchmark"

valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose  ./build/test/run-tests "rtree basic ops"
  #+end_src

* <2022-03-16 Wed> overloading new etc
  - https://stackoverflow.com/questions/4638429/c-placement-new-vs-overloading-new
  - https://stackoverflow.com/questions/58225405/c-14-overload-new-operator-to-allocate-more-continuous-space-than-objects-s
    static_cast??
    https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used

    https://stackoverflow.com/questions/12215029/c-placement-new-collides-with-own-new-overload?rq=1

    https://bytes.com/topic/c/answers/583571-overriding-placement-new-correctly
    nice answers (quoting some c++ books)

    https://www.amazon.de/Modern-Generic-Programming-Patterns-Applied/dp/0201704315
    has a chapter for allocations
    as seen https://eli.thegreenplace.net/2011/02/17/the-many-faces-of-operator-new-in-c
